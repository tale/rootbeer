const std = @import("std");
const zlua = @import("zlua");
const Lua = zlua.Lua;

/// Registry key for the context pointer.
const registry_key = "_ROOTBEER_CTX";

/// Tracked execution context for generating deterministic revisions.
/// Populated during `rb apply <file>` as plugins and Lua scripts run.
pub const Context = struct {
    allocator: std.mem.Allocator,

    script_path: [:0]const u8,
    script_dir: []const u8,

    /// Extra Lua modules required by the script, tracked via the require hook.
    lua_modules: std.ArrayList([]const u8) = .empty,

    /// Additional static inputs (templates, files to link, etc.).
    static_inputs: std.ArrayList([]const u8) = .empty,

    /// Intermediate files generated by plugins, keyed by ID.
    intermediates: std.StringHashMap([]const u8),

    /// Output files produced by the revision.
    generated: std.ArrayList([]const u8) = .empty,

    /// Extra input files used by plugins, relative to the script path.
    ext_files: std.ArrayList([]const u8) = .empty,

    /// Intermediate files generated by plugin transforms.
    plugin_transforms: std.ArrayList([]const u8) = .empty,

    /// When true, no files are written or linked â€” only print what would happen.
    dry_run: bool,

    /// Output buffer for rb.line() and rb.emit() primitives.
    output: std.ArrayList(u8) = .empty,

    pub fn init(allocator: std.mem.Allocator, io: std.Io, script_path: []const u8, dry_run: bool) !Context {
        const cwd = std.Io.Dir.cwd();
        const abs_path = try cwd.realPathFileAlloc(io, script_path, allocator);
        errdefer allocator.free(abs_path);

        const dir = std.fs.path.dirname(abs_path) orelse "/";
        const script_dir = try allocator.dupe(u8, dir);
        errdefer allocator.free(script_dir);

        return .{
            .allocator = allocator,
            .script_path = abs_path,
            .script_dir = script_dir,
            .intermediates = std.StringHashMap([]const u8).init(allocator),
            .dry_run = dry_run,
        };
    }

    pub fn deinit(self: *Context) void {
        self.allocator.free(self.script_path);
        self.allocator.free(self.script_dir);

        for (self.lua_modules.items) |s| self.allocator.free(s);
        self.lua_modules.deinit(self.allocator);

        for (self.static_inputs.items) |s| self.allocator.free(s);
        self.static_inputs.deinit(self.allocator);

        var it = self.intermediates.iterator();
        while (it.next()) |entry| {
            self.allocator.free(entry.key_ptr.*);
            self.allocator.free(entry.value_ptr.*);
        }
        self.intermediates.deinit();

        for (self.generated.items) |s| self.allocator.free(s);
        self.generated.deinit(self.allocator);

        for (self.ext_files.items) |s| self.allocator.free(s);
        self.ext_files.deinit(self.allocator);

        for (self.plugin_transforms.items) |s| self.allocator.free(s);
        self.plugin_transforms.deinit(self.allocator);

        self.output.deinit(self.allocator);
    }

    /// Store a pointer to this context in the Lua registry.
    pub fn registerInLua(self: *Context, lua: *Lua) void {
        lua.pushLightUserdata(self);
        lua.setField(zlua.registry_index, registry_key);
    }

    /// Retrieve the context pointer from the Lua registry.
    pub fn fromLua(lua: *Lua) *Context {
        _ = lua.getField(zlua.registry_index, registry_key);
        const ptr = lua.toUserdata(Context, -1) catch {
            lua.pop(1);
            lua.raiseErrorStr("rootbeer context not registered", .{});
        };
        lua.pop(1);
        return ptr;
    }
};

test "context init and deinit" {
    var ctx = try Context.init(std.testing.allocator, std.testing.io(), "build.zig", false);
    defer ctx.deinit();

    try std.testing.expect(std.mem.endsWith(u8, ctx.script_path, "build.zig"));
    try std.testing.expect(ctx.script_dir.len > 0);
    try std.testing.expectEqual(false, ctx.dry_run);
}
